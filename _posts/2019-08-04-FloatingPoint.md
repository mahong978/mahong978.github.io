---
layout: post
title: "浮点数"
date:   2019-08-04 21:24
categories: Java
tags: Java
---

* content
{:toc}

突然发现浮点数的存储格式都忘得一干二净了，于是百科了一番复习

## 科学计数法

计算机中浮点数的记录形式类似与科学计数法，一个数字可以用下面的形式表示
$$
number = significand \times base ^ {exponent}
$$

其中significand即有效数字，base是基数，exponent是幂数。其精确度受有效数字和幂数的长度限制

而浮点数的基数为2，即表示为
$$
a = m \times 2 ^ e
$$

其中m即尾数（mantissa），e即幂数（exponent）。当m是非0数字开头时，则称m是正规化的

## IEEE 754

以前浮点数的记录形式很混乱，后来IEEE 754统一了标准

以32位（单精度）浮点数为例，在最低有效位（LSB）的格式下

最高位（31）为符号位，0表示正数，1表示负数

中间8位（30-23）为指数，或者叫阶码，格式可以是补码或移码。当是移码时，单精度的偏移值是-127，双精度的偏移值是-1023

后面23为（22-0）为尾数，不包含整数的1，只记录小数部分

对于00111110001000000000000000000000，转换成实际值为：

$$
{sign} = +1
$$
$$
{exponent} = (01111100)_2 = -127 + 124 = -3
$$
$$
{mantissa} = 1 + (01000000000000000000000)_2 = 1 + 2 ^ {-2} = 1.25
$$
$$
{value} = {sign} \times {mantissa} \times 2 ^ {exponent} = 0.15625
$$

而64位（双精度）浮点数的指数位长度为11位，尾数位长度为53位

指数位全为0或全为1时

|       | 尾数为0 | 尾数不为0      |
| ----- | ------- | -------------- |
| 全为0 | 带符号0 | 非正规化浮点数 |
| 全为1 | 无穷    | NaN            |

注意，当表示非正规化浮点数时，实际指数为-126而不是-127，因为正规化浮点数的最小值是$2 ^ {-216}$

设B为基数，P是尾数位数，L是最小指数，U是指数，则可表示的浮点数的个数为
$$
2(B-1)(B^{P-1})(U-L+1)+1
$$

可表示的最小正规化浮点数，即下溢值为
$$
UFL = B ^ L
$$

可表示的最大正规化浮点数，即上溢值为
$$
OFL = （1-B^{-P}）(B^{U+1})
$$

注：这里很奇怪，应该是用U而不是U+1吧

## 舍入规则

舍入规则有五种

### 舍入到最近

- 舍入到最近的值; 如果发生舍入的数字是在中间，则舍入到最近的偶数位有效数字。这是推荐的默认方法
- 舍入到最近的值; 如果发生舍入的数字是在中间，正数则向上，负数则向下

### 方向舍入

- 向0舍入; 向0方向舍入，也就是截断
- 向正无穷舍入; 向正无穷方向舍入，也就是向上（ceil）
- 向负无穷舍入; 向负无穷方向舍入，也就是向下（floor）