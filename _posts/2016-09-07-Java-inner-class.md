---
layout: post
title:  "Java笔记整理：内部类"
date:   2016-09-07 13:30
categories: java
tags: java
excerpt: 《Java编程思想》第十章
---

* content
{:toc}





内部类：将一个类的定义放在另一个类的定义内部

把一些逻辑相关的类组织在一起，并控制内部类的可视性

内部类与组合是完全不同的概念


-----------------

## 创建内部类

从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体指明对象的类型：OuterClassName.InnerClassName


----------
	
## 链接到外部类

内部类对象能访问其外围对象的所有成员，不需要任何条件

当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用，用这个引用来访问外围类的成员


----------

## .this和 .new

如果内部类需要得到对应外部类对象的引用，使用外部类名 + .this

手动创建内部类对象时，由于需要外部类对象为前提，所以在new表达式中要提供外部类对象的引用

必须使用外部类对象来创建内部类对象

在拥有外部类对象之前是不可能创建内部类对象的

如果内部类是嵌套类（静态内部类），则不需要外部类对象的前提


----------

## 内部类和向上转型

当内部类是实现了某个接口，然后将一个对象向上转型为接口类型，就可以很好地隐藏内部类的细节

private内部类甚至不能访问其名字，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节


----------

## 方法和作用域内的内部类

可以在一个方法里面或者在任意的作用域内定义内部类

理由：

1. 快速实现某个接口并返回其引用
2. 需要一个辅助的类，但又不希望它是公共可用的
		
在方法作用域内定义的类称作局部内部类

局部内部类的定义不会造成命名冲突

局部内部类在编译时已经被编译了，因此其定义与作用域无关，而是在该作用域外不可用


----------

## 匿名内部类

使用匿名内部类可以快速返回一个基类或接口的实现

return new 基类/接口名(参数列表) {实现}

<br/>
如果定义一个匿名内部类，需要使用一个在定义外部的对象，那么这个对象的引用必须是final的

匿名内部类没有名字，因此没有构造器，如果需要进行一些初始化，可以使用实例初始化

匿名内部类可以继承类，也可以实现接口，但是只能选一个，而且只能实现一个接口


----------

## 嵌套类

静态的内部类即嵌套类

创建嵌套类的对象，不需要外围类的对象

不能用嵌套类的对象访问非静态的外围类对象

普通内部类不能有静态数据和静态字段，而嵌套类可以有
	
### 接口内部
接口内部可以放置嵌套类（由于放置在接口中的类都自动是public和static的）

可以在内部类中实现其外围接口

在一个接口中预置多种实现，可以使用嵌套类进行实现
		
<br/>
内部类可以访问所有它嵌入的外围类的所有成员


------------------	

## 为什么需要内部类

由于内部类可以访问外围类的成员，所以内部类提供某种访问外围类的窗口

每个内部类都可以独立得继承一个接口的实现，对外围类来说相当于某种意义上的多重继承

内部类的其他特性：

1. 内部类可以有多个实例，内部类的状态都是相互独立的
2. 在一个外围类内可以让多个内部类以不同形式实现一个接口
3. 内部类是一个独立的实体
	
### 闭包和回调

闭包是一个可调用的对象，它记录了一些信息，这些信息来自创建它的作用域

内部类是面向对象的闭包

JAVA通过闭包提供了回调机制，可以在运行时动态地决定调用什么方法


----------	

## 内部类的继承
由于内部类的实例化需要外围类的对象，所以内部类的导出类，其构造器必须要有那个外围类对象的引用，然后再构造器中调用super()，才能编译通过


----------
	
## 内部类的覆盖
基类和导出类中的两个同名内部类是相互独立的，各自在自己的命名空间中
	
局部内部类不能有访问说明符，因为它不是外围类的成员


----------

## 内部类标识符
内部类的类文件名为：外围类名字 + $ + 内部类名字

如果内部类是匿名的，会产生一个数字作为标识符

<br/>
如果一个内部类是嵌套在别的内部类中，直接将其名字放在外围类标识符和$后面
