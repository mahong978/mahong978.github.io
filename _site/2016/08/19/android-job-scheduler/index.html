<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>JobScheduler学习</title>
    <meta name="description" content="后台任务是应用开发中常见的问题。最简单的做法就是直接开一个Thread，用Handler通信即可，但是所开的线程和活动是没有关系的，一旦应用被杀死，就和之前所创建的线程失去了联系，就算活动再次启动，此时启动的线程并不是之前的线程。当然，这个问题可以用Service解决，那么如果用户把服务也杀了呢？你可能会想用Al...">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href=" /css/fontawesome/css/font-awesome.min.css ">
    <link rel="stylesheet" href=" /css/main.css ">
    <!--<link rel="stylesheet" href=" /css/syntax.css ">-->
    <link rel="canonical" href="http://mahong978.github.io/2016/08/19/android-job-scheduler/">
    <link rel="alternate" type="application/rss+xml" title="Mahong" href="http://mahong978.github.io /feed.xml ">


    <script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c4e3e6dfb970411c574e62c2c06e0c41";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-72449510-4', 'auto');
      ga('send', 'pageview');

    </script>

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">Mahong</a>
        <small>Android Developer</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>主页
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>存档
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>分类
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>标签
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/collection/">
                        
                            <i class="fa fa-bookmark"></i>Collections
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/demo/">
                        
                            <i class="fa fa-play"></i>Demo
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>JobScheduler学习</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2016-08-19
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Android" title="Category: Android" rel="category">Android</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


            </div>

            <div class="label-card">
            
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#Android" title="Tag: Android" rel="tag">Android</a-->
        <a href="/tag/#Android" title="Tag: Android" rel="tag">Android</a>
    
  

</span>

            </div>

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <ul id="markdown-toc">
  <li><a href="#api" id="markdown-toc-api">API成员</a>    <ul>
      <li><a href="#jobinfo" id="markdown-toc-jobinfo">JobInfo</a>        <ul>
          <li><a href="#jobinfobuilder" id="markdown-toc-jobinfobuilder">JobInfo.Builder</a></li>
        </ul>
      </li>
      <li><a href="#jobparameters" id="markdown-toc-jobparameters">JobParameters</a></li>
      <li><a href="#jobscheduler" id="markdown-toc-jobscheduler">JobScheduler</a></li>
      <li><a href="#jobservice" id="markdown-toc-jobservice">JobService</a></li>
    </ul>
  </li>
</ul>

<p>后台任务是应用开发中常见的问题。</p>

<p>最简单的做法就是直接开一个Thread，用Handler通信即可，但是所开的线程和活动是没有关系的，一旦应用被杀死，就和之前所创建的线程失去了联系，就算活动再次启动，此时启动的线程并不是之前的线程。</p>

<p>当然，这个问题可以用Service解决，那么如果用户把服务也杀了呢？你可能会想用AlarmManager，周期性地进行唤醒，可是用户关机了，AlarmManager也就没了。当然这还没到“穷途末路”，用BroadcastReceiver就可以直接解决服务自启的所有问题。</p>

<p>但是让我们换个角度来看，打开管理器查看当前活动的服务就能看到，这些一直在活动的后台往往是导致手机耗电飞快的原因。当然这种问题是需要开发者的自觉的，如果让开发者来考虑省电，这将会是开发者的一大烦恼，比如说希望连接WiFi时才进行，插入充电器才进行，将会使代码大大增加；另一方面，万一此时没有网络可用呢？还得写一个BroadcastReceiver来监听网络情况。超级麻烦的不是吗？</p>

<p>Android L开始引入了一个新的API：JobScheduler。正如其名，它允许将任务调度直接交给系统，并且你所需要的许多约束条件，如周期调度，延迟调度，网络连接，电源插入，还有Android L引入的空闲模式（虽然现在还挺鸡肋），都可以快捷地进行设置。现在就开始对JobScheduler的学习</p>

<hr />
<h2 id="api">API成员</h2>

<h3 id="jobinfo">JobInfo</h3>

<p>代表一个任务，使用建造者模式进行制造，然后传递给JobScheduler进行调度管理。需要注意的是JobInfo类中的几个常量，建造时需要用到，至于作用会在后面的set方法中介绍：</p>

<ul>
  <li>BACKOFF_POLICY_EXPONENTIAL</li>
  <li>BACKOFF_POLICY_LINEAR</li>
  <li>DEFAULT_INITIAL_BACKOFF_MILLIS</li>
  <li>MAX_BACKOFF_DELAY_MILLIS</li>
  <li>NETWORK_TYPE_ANY</li>
  <li>NETWORK_TYPE_NONE</li>
  <li>NETWORK_TYPE_NOT_ROAMING</li>
  <li>NETWORK_TYPE_UNMETERED</li>
</ul>

<h4 id="jobinfobuilder">JobInfo.Builder</h4>
<p>JobInfo的建造者，其构造器为：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">JobInfo</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="kt">int</span> <span class="n">jobId</span><span class="o">,</span> <span class="n">ComponentName</span> <span class="n">jobService</span><span class="o">)</span>
</code></pre>
</div>

<p>第一个参数为该任务的标识符，该标识符在相同的uid的所有客户端中必须是唯一的（官方文档是这么写的，我的理解是在该设备上必须是唯一的）。为了保证在应用升级后也是稳定的，因此建议不要基于资源id进行设置</p>

<p>第二个参数是你希望用来处理该任务的服务对应的ComponentName，用来启动该服务</p>

<p>接下来是用来建造JobInfo的各个参数对应的set方法：</p>

<ul>
  <li>
    <p>setBackoffCriteria(long initialBackoffMillis, int backoffPolicy)</p>

    <p>设置退避/重试策略。类似网络原理中的冲突退避，当一个任务的调度失败时需要重试，所采取的策略。</p>

    <p>第一个参数时第一次尝试重试的等待间隔，单位为毫秒，预设的参数有：</p>

    <ul>
      <li>
        <p>DEFAULT_INITIAL_BACKOFF_MILLIS</p>

        <p>30000</p>
      </li>
      <li>
        <p>MAX_BACKOFF_DELAY_MILLIS</p>

        <p>18000000</p>
      </li>
    </ul>

    <p>第二个参数是对应的退避策略，预设的参数有：</p>

    <ul>
      <li>
        <p>BACKOFF_POLICY_EXPONENTIAL</p>

        <p>二进制退避。等待间隔呈指数增长</p>
      </li>
      <li>
        <p>BACKOFF_POLICY_LINEAR</p>
      </li>
    </ul>
  </li>
  <li>
    <p>setMinimumLatency(long minLatencyMillis)</p>

    <p>设置任务执行延迟的时长</p>
  </li>
  <li>
    <p>setOverrideDeadline(long maxExecutionDelayMillis)</p>

    <p>设置任务的最大延迟时长。一旦达到该时间，无论条件是否满足，任务都会执行</p>

    <p>由于设置延迟对周期性任务来说没有意义，因此在build()时会抛出IllegalArgumentException异常</p>
  </li>
  <li>
    <p>setPeriodic (long intervalMillis)</p>

    <p>设置周期。可以保证在每个间隔之间任务最多只执行一次</p>
  </li>
  <li>
    <p>setPeriodic (long intervalMillis, long flexMillis)</p>

    <p>在周期末的一个flex长度的窗口，任务都有可能被执行</p>
  </li>
  <li>
    <p>setPersisted (boolean isPersisted)</p>

    <p>设置设备重启后，这个任务是否还保留。需要RECEIVE_BOOT_COMPLETED权限</p>
  </li>
  <li>
    <p>setRequiredNetworkType (int networkType)</p>

    <p>设置要求的网络，只有接入给定类型的网络才能执行，而且是必须要接入网络才能执行。预置的参数有：</p>
  </li>
  <li>
    <p>NETWORK_TYPE_NONE</p>

    <p>默认值。表示与网络状态无关</p>
  </li>
  <li>
    <p>NETWORK_TYPE_ANY</p>

    <p>必须连接网络</p>
  </li>
  <li>
    <p>NETWORK_TYPE_NOT_ROAMING</p>

    <p>必须连接非漫游的网络</p>
  </li>
  <li>
    <p>NETWORK_TYPE_UNMETERED</p>

    <p>必须连接非计费的网络</p>
  </li>
  <li>
    <p>setRequiresCharging (boolean requiresCharging)</p>

    <p>设置是否需要充电器接入。默认false</p>
  </li>
  <li>
    <p>setRequiresDeviceIdle (boolean requiresDeviceIdle)</p>

    <p>设置是否需要设备处于空闲状态。默认false。空闲状态指设置已经有一段时间没有被使用</p>
  </li>
  <li>
    <p>addTriggerContentUri (JobInfo.TriggerContentUri uri)</p>

    <p>添加一个TriggerContentUri，该Uri将利用ContentObserver来监控一个Content Uri，当且仅当其发生变化时将触发任务的执行</p>

    <p>这个功能不能和setPeriodic(long)或者setPersisted(boolean)一起使用， 因为这样是没有意义的，否则在build()时会抛出IllegalArgumentException异常</p>

    <p>为了持续监控content的变化，你需要在最近的任务触发后再调度一个新的任务</p>
  </li>
  <li>
    <p>setTriggerContentMaxDelay (long durationMs)</p>

    <p>设置从content变化到任务被执行，中间的最大延迟</p>
  </li>
  <li>
    <p>setTriggerContentUpdateDelay (long durationMs)</p>

    <p>设置从content变化到任务被执行中间的延迟。如果在延迟期间content发生了变化，延迟会重新计算</p>
  </li>
  <li>
    <p>build()</p>

    <p>创建对应的JobInfo</p>
  </li>
  <li>
    <p>JobInfo.TriggerContentUri</p>

    <p>保存了一项任务触发绑定的content uri信息</p>

    <p>其构造器为：</p>

    <p><code class="highlighter-rouge">
  JobInfo.TriggerContentUri(Uri uri, int flags)
 </code></p>

    <div class="highlighter-rouge"><pre class="highlight"><code>第一个参数是希望监控的content的Uri，第二个参数是标识符
</code></pre>
    </div>
  </li>
</ul>

<hr />
<h3 id="jobparameters">JobParameters</h3>
<p>当任务被调度，交由应用处理时提供的对象，包含了该任务的信息。无法自己创建JobParameter的实例</p>

<p>由于是用来提供任务信息的，所以基本都是get方法：</p>

<ul>
  <li>PersistableBundle getExtras()</li>
  <li>int getJobId()</li>
  <li>
    <p>String getTriggeredContentAuthorities()</p>

    <p>获得触发该任务的content authorities</p>
  </li>
  <li>Uri[] getTriggeredContentUris()</li>
  <li>
    <p>boolean isOverrideDeadlineExpired()</p>

    <p>判断该调度是否因为达到deadline了</p>
  </li>
</ul>

<hr />
<h3 id="jobscheduler">JobScheduler</h3>

<p>负责调度任务。一般调用schedule(JobInfo)方法将任务加入到调度队列中。JobScheduler无法自己创建，因为是系统级的服务，所以用Context.getSystemService(Context.JOB_SCHEDULER_SERVICE)获得其实例</p>

<ul>
  <li>
    <p>int schedule(JobInfo)</p>

    <p>将任务加入到调度队列中。将会返回一个结果</p>

    <ul>
      <li>
        <p>RESULT_SUCCESS</p>

        <p>加入成功</p>
      </li>
      <li>
        <p>RESULT_FAILURE</p>

        <p>不合法的参数将会导致失败，有可能是该任务的run-time太短（不是很懂），或者其指定的JobService无法解析</p>
      </li>
    </ul>
  </li>
  <li>
    <p>cancel(int jobId)</p>

    <p>取消对应ID的任务</p>
  </li>
  <li>
    <p>cancelAll()</p>

    <p>取消由这个包注册的所有任务</p>
  </li>
  <li>
    <p>List&lt; JobInfo &gt; getAllPendingJobs()</p>

    <p>获得这个包注册的正在等待的任务</p>
  </li>
  <li>
    <p>JobInfo getPendingJob(int jobId)</p>

    <p>获得指定的由该包注册的正在等待的任务</p>
  </li>
</ul>

<hr />
<h3 id="jobservice">JobService</h3>

<p>JobScheduler的回调入口。</p>

<p>由于需要应用来完成任务的执行，因此需要继承该类，重载其onStartJob(JobParameter)方法，进行任务的执行</p>

<p>建议使用Handler来完成任务执行的逻辑，以防阻塞未来的任务</p>

<p>在Manifest注册该Service时，要注意添加android.permission.BIND_JOB_SERVICE权限，否则会被系统忽略</p>

<ul>
  <li>
    <p>void jobFinished (JobParameters params, boolean needsReschedule)</p>

    <p>当完成任务的执行时，调用该方法通知JobManager。该方法可以在任何线程调用</p>

    <p>第一个参数是该任务对应的JobParameter，你会在onStartJob方法获得</p>

    <p>第二个参数表示是否需要重新调度。退避机制会产生作用，也就是重调度的任务加入到队列中后，将会等待一段时间才能获得调度。在设备空闲模式下，退避机制不会产生作用</p>
  </li>
  <li>
    <p>boolean onStartJob (JobParameters params)</p>

    <p>JobService将会在这个回调方法获得可执行的任务，如果该任务不需要额外的执行，可以立即返回false。否则需要在单独的线程中执行（使用Handler），并且返回true，在任务执行完后调用jobFinished()方法进行通知</p>
  </li>
  <li>
    <p>boolean onStopJob (JobParameters params)</p>

    <p>当你主动通知任务执行完毕（jobFinished）之前，系统可能会要求你停止任务，这时将会调用onStopJob方法</p>

    <p>当该任务的需求不再满足时将发生这种状况，必须对此做出反应，否则应用可能会出现行为异常。一种立即引起的影响就是系统可能会将你的wakelock释放</p>

    <p>返回true表示你希望对该任务重新进行调度，同样需要遵守退避策略；返回false表示你希望放弃该任务</p>
  </li>
</ul>

<hr />

<p>关于JobScheduler API的学习大概就是这么多了，可以看到Google从Android L开始就很关注电池续航的问题，包括M的doze mode也是一样，估计N也会引入更好的省电策略。看到网上关于这块的中文资料都不是挺全面，于是就自己尝试对整个API进行学习，感觉还行吧，就酱。</p>

<p>另附：</p>

<p><a href="https://github.com/googlesamples/android-JobScheduler">官方Sample</a></p>

<p><a href="https://developer.android.com/reference/android/app/job/package-summary.html">JobScheduler官方文档</a></p>

        </article>
        <hr>

        
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                        
                        <h2 id="similar_posts">Similar Posts</h2>
                        <ul>
                        
                        <li class="relatedPost">
                            <a href="http://mahong978.github.io/2016/08/29/firebase-realtime-database2/">Firebase初探：实时数据库(2)
                            
                            </a>
                        </li>
                        
                        
                    
                
            
                
                    
                
            
        
            
            
                
                    
                        
                        <li class="relatedPost">
                            <a href="http://mahong978.github.io/2016/08/28/firebase-realtime-database/">Firebase初探：实时数据库(1)
                            
                            </a>
                        </li>
                        
                        
                    
                
            
                
                    
                
            
        
        
            </ul>
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2016/08/16/android-data-binding/">Data binding学习</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2016/08/20/android-permission-request/">Android M之权限请求</a></p>
        
    </div>
</div>


        <h2 id="comments">Comments</h2>
        
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="http://mahong978.github.io/2016/08/19/android-job-scheduler/" data-title="JobScheduler学习" data-url="http://mahong978.github.io/2016/08/19/android-job-scheduler/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    var duoshuoQuery = {
        short_name: "mahong978"
    };
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->






    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

            <!-- Content -->
            <div class="side content">
                <div>
                    Content
                </div>
                <ul id="content-side" class="content-ul">
                    <li><a href="#similar_posts">Similar Posts</a></li>
                    <li><a href="#comments">Comments</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             个人博客 
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/mahong978" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:1350374964@qq.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>  
            <a href="http://weibo.com/mahq" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a>  
            <a href="https://www.zhihu.com/people/ma-hong-66" title="Zhihu"><i class="iconfont">&#xe829;</i></a>   
            <a href="https://www.facebook.com/mahong978" title="Facebook"><i class="fa fa-facebook-official" aria-hidden="true"></i></a>    
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" class="scroll">
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/scroll.min.js " charset="utf-8"></script>
  </body>

</html>
