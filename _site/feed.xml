<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mahong</title>
    <description></description>
    <link>http://mahong978.github.io/</link>
    <atom:link href="http://mahong978.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 08 Sep 2016 23:29:30 +0800</pubDate>
    <lastBuildDate>Thu, 08 Sep 2016 23:29:30 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Android N新特性：direct reply notification</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;主要流程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#notification&quot; id=&quot;markdown-toc-notification&quot;&gt;构建Notification&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#remoteinput&quot; id=&quot;markdown-toc-remoteinput&quot;&gt;RemoteInput&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#notificationcompataction&quot; id=&quot;markdown-toc-notificationcompataction&quot;&gt;NotificationCompat.Action&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#pendingintent&quot; id=&quot;markdown-toc-pendingintent&quot;&gt;PendingIntent&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#notificationcompatbuilder&quot; id=&quot;markdown-toc-notificationcompatbuilder&quot;&gt;NotificationCompat.Builder&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;处理回复&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;更新通知&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Android N带来了一系列新功能，比如分屏与画中画，更好的后台管理等，其中就包括了direct reply notification，顾名思义，就是可以直接回复的通知。&lt;/p&gt;

&lt;p&gt;试想一下，在以往的Android系统中，你正在使用的一款社交应用不在前台时，当有新消息时往往是以通知的方法进行提醒的，这时你从状态栏下滑，显示出通知列表，然后点击那个通知进入应用的聊天界面，最后才进行回复。这中间包括了多个手势和界面跳转，当应用优化或者手机性能较差时，这将会花上相当的时间，所带来的用户体验将会是比较差的。&lt;/p&gt;

&lt;p&gt;Android N带来的直接回复通知的功能，允许用户直接在通知控件上进行回复，这就免去了上面所述的步骤，优化了用户体验。下面就让我们对direct reply notification进行研究&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;主要流程&lt;/h2&gt;

&lt;p&gt;在开始之前，先来理清一下中间的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接收消息一般是使用Service在后台运行&lt;/li&gt;
  &lt;li&gt;当有新消息时，Service发出Notification&lt;/li&gt;
  &lt;li&gt;用户在通知上回复后，需要进行发送，由于通知的响应是通过PendingIntent进行的，所以这里使用IntentService来负责发送是最好的&lt;/li&gt;
  &lt;li&gt;IntentService发送完后，发送广播，Service监听相关广播，收到广播后进行通知的更新&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;主要流程大概就是这样，下面就开始一步步地来进行探索&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notification&quot;&gt;构建Notification&lt;/h2&gt;

&lt;p&gt;监听消息的Service在接收一条新消息后，将发出一条通知，那么直接回复的通知是如何构建的呢？&lt;/p&gt;

&lt;p&gt;这里要先了解一下RemoteInput。RemoteInput原先是在Android Wearable的API中使用的，通过Notification.Builder的setRemoteInput方法设置，可以让用户在手表的通知上进行语音回复。现在RemoteInput也能进行文字输入了，它将在这里发挥重要作用。&lt;/p&gt;

&lt;p&gt;我们知道，Android L开始，通知可以通过添加action，在通知控件上添加额外的交互控件来提供额外的操作，这里也一样，RemoteInput是通过Notification.Action加入到Notification中的&lt;/p&gt;

&lt;h3 id=&quot;remoteinput&quot;&gt;RemoteInput&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;RemoteInput&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remoteInput&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RemoteInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KEY_REPLY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setLabel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;RemoteInput使用了建造者模式，RemoteInput.Builder的构造函数中需要提供一个String类型的resultKey，这个key将会在后面提取用户输入内内容的时候用到。setLabel()方法是设置用户点开输入框后的hint文字&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;notificationcompataction&quot;&gt;NotificationCompat.Action&lt;/h3&gt;

&lt;p&gt;由于RemoteInput是v4 support包的，因此这里的通知是使用v4 support的NotificationCompat进行构建的&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;NotificationCompat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Action&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NotificationCompat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mipmap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ic_launcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;pendingIntent&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addRemoteInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remoteInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Builder构造器的三个参数分别是该action对应的icon资源（在这里好像没什么用），action的标题，对应的PendingIntent（用于启动处理消息回复）。
Builder调用addRemoteInput()方法设置RemoteInput&lt;/p&gt;

&lt;h4 id=&quot;pendingintent&quot;&gt;PendingIntent&lt;/h4&gt;

&lt;p&gt;我们这里的PendingIntent是用来启动负责消息回复的成员，它可以是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Service或者BroadcastReceiver
 它们没有UI，适合后台操作，因此是直接回复通知的最佳选择&lt;/li&gt;
  &lt;li&gt;Activity
 具有UI ，会关闭通知栏，会要求用户解锁设备&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此对于Android N以下的系统，由于SDK不直接支持RemoteInput，而且你需要让用户知道程序有没有在进行回复，应该启动Activity。对于Android N或以上的系统，应该启动Service或BroadcastReceiver&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sendIntent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SendService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PendingIntent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pendingIntent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PendingIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CODE_NEW_MESSAGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sendIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PendingIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;FLAG_ONE_SHOT&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;notificationcompatbuilder&quot;&gt;NotificationCompat.Builder&lt;/h3&gt;

&lt;p&gt;Notification.Builder的使用以及通知的发送就不用介绍了：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NotificationCompat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setSmallIcon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mipmap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ic_launcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setStyle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NotificationManager&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NotificationManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getSystemService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;NOTIFICATION_SERVICE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID_NEW_MESSAGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notification.Builder的setStyle方法可以给通知添加样式，API预置的样式有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Notification.BigPictureStyle&lt;/li&gt;
  &lt;li&gt;Notification.BigTextStyle&lt;/li&gt;
  &lt;li&gt;Notification.DecoratedCustomViewStyle&lt;/li&gt;
  &lt;li&gt;Notification.InboxStyle&lt;/li&gt;
  &lt;li&gt;Notification.MediaStyle&lt;/li&gt;
  &lt;li&gt;Notification.MessagingStyle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中MessagingStyle很适合在这种情境下使用&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NotificationCompat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MessagingStyle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;我&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setConversationTitle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;吃货日常&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;今晚吃点啥&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;mahong&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中构造器的参数是用户的显示名，setConversationTitle()是设置此次对话的标题，addMessage()是添加一条消息，参数分别是消息内容，时间戳以及对方的用户名（如果是用户自己发出的则设为null）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;处理回复&lt;/h2&gt;

&lt;p&gt;当用户进行了回复后，回复内容会被包装在一个Intent中，发送到action的PendingIntent指向的Service，BroadcastReceiver或Activity&lt;/p&gt;

&lt;p&gt;取出Intent内容的方法不是通常的getExtra()，而是通过RemoteInput.getResultFromIntent()取出的&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onHandleIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RemoteInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getResultsFromIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replyText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCharSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReceiveService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;KEY_REPLY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replyIntent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;replyIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.mahong.test.SEND_OVER&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;replyIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putExtra&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReceiveService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;KEY_REPLY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replyText&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sendBroadcast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replyIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里省略去了发送回复的逻辑&lt;/p&gt;

&lt;p&gt;需要注意的是，从Bundle中取出文本时使用的键，是创建RemoteInput对象时指定的键&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;更新通知&lt;/h2&gt;

&lt;p&gt;用户点击发送按钮回复后，发送按钮会变成一个progress小圆圈，如果你在上面那步就结束的话，这个progress小圆圈就会一直转个不停，这样的用户体验显然是不好的，因此需要在消息发送成功后更新通知&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onReceive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CharSequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCharSequenceExtra&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KEY_REPLY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;NotificationManager&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NotificationManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getSystemService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;NOTIFICATION_SERVICE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是使用MessagingStyle的话，用addMessage()加上用户的回复，然后重新build()一下，用相同的id再发一次通知就行了&lt;/p&gt;

&lt;p&gt;对于其他的style，则需要使用setRemoteInputHistory()来添加回复&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;整个流程大概就是这样，让我们来看看效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://od654njdm.bkt.clouddn.com/test.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Sep 2016 16:40:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/08/Android-DRN/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/08/Android-DRN/</guid>
        
        <category>Android</category>
        
        <category>Notification</category>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：持有对象</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;泛型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;基本概念&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;添加一组元素&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;容器的打印&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#list&quot; id=&quot;markdown-toc-list&quot;&gt;List&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;迭代器&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#listiterator&quot; id=&quot;markdown-toc-listiterator&quot;&gt;ListIterator&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#linkedlist&quot; id=&quot;markdown-toc-linkedlist&quot;&gt;LinkedList&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#stack&quot; id=&quot;markdown-toc-stack&quot;&gt;Stack&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#set&quot; id=&quot;markdown-toc-set&quot;&gt;Set&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#map&quot; id=&quot;markdown-toc-map&quot;&gt;Map&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#queue&quot; id=&quot;markdown-toc-queue&quot;&gt;Queue&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#priorityqueue&quot; id=&quot;markdown-toc-priorityqueue&quot;&gt;PriorityQueue&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#collectioniterator&quot; id=&quot;markdown-toc-collectioniterator&quot;&gt;Collection和Iterator&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#foreach&quot; id=&quot;markdown-toc-foreach&quot;&gt;foreach和迭代器&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;适配器方法惯用法&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;《Java编程思想》第十一章&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一个程序只包含固定数量的且生命周期都是已知的对象，那么这是一个非常简单的程序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
JAVA实用类库提供了一套容器类，其中基本的类型是List，Set，Queue和Map。也称为集合类&lt;/p&gt;

&lt;p&gt;可以将任意数量的对象放置到容器中&lt;/p&gt;

&lt;p&gt;JAVA中的容器都是类，也就是说JAVA没有直接的关键字支持&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;泛型&lt;/h2&gt;

&lt;p&gt;泛型指定了容器中元素的类型，访问元素时返回的是泛型类型的引用，可能需要自己转型&lt;/p&gt;

&lt;p&gt;可以为容器指定多个泛型&lt;/p&gt;

&lt;p&gt;使用泛型，可以在编译期防止错误类型的放置&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
打印对象时可能产生的无符号十六进制数，是由hashCode方法产生的&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;容器类可以分为两个概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Collection：独立元素的序列，元素的排序服从一条或多条规则。其中包含：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;List：必须按照插入的顺序保存元素&lt;/li&gt;
      &lt;li&gt;Set：不能有重复元素&lt;/li&gt;
      &lt;li&gt;Queue：按照排队规则来确定对象产生的顺序（通常与被插入顺序相同）&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;所有的Collection对象能使用foreach语法遍历&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Map：一组成对的“键值对”对象，允许使用键来查找值。映射表允许使用一个对象（不是引用）来查找另一个对象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;添加一组元素&lt;/h3&gt;
&lt;p&gt;Arrays.asList()方法接受一个数组，或者一个用逗号分隔的元素列表（可变参数），并将其转换为一个List对象&lt;/p&gt;

&lt;p&gt;Collections.addAll()方法接受一个Collection对象，以及一个数组或是逗号分隔的列表，将元素添加到Collection对象中&lt;/p&gt;

&lt;p&gt;Collection.addAll()方法接受一个Collection对象，将该对象的元素添加到方法调用者中&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;		
Collection.addAll()运行更快，但不够灵活&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
Arrays.asList()方法返回的List是和数组链接在一起的，因此不能对返回的List做插入和删除操作&lt;/p&gt;

&lt;p&gt;可以指定asList方法返回列表的目标类型：Arrays.&lt;E&gt;asList()&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
对于Map的初始化，除了用另一个Map之外，没有其他的初始化方式&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;容器的打印&lt;/h3&gt;
&lt;p&gt;对于数组，必须使用Arrays.toString()方法进行打印&lt;/p&gt;

&lt;p&gt;对于容器，则无需任何帮助&lt;/p&gt;

&lt;p&gt;对于Set和Map，除了LinkedHash的，其他类型的都不是按插入顺序存储的&lt;/p&gt;

&lt;h3 id=&quot;list&quot;&gt;List&lt;/h3&gt;
&lt;p&gt;有两种类型的List：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ArrayList：擅长随机访问元素，但是中间插入和移除元素较慢&lt;/li&gt;
  &lt;li&gt;LinkedList：优化中间插入和移除元素，随机访问较慢，但是特性集比ArrayList大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;contain：确定某个对象是否在列表中（containsAll，顺序无关）&lt;/p&gt;

&lt;p&gt;indexOf：发现对象在List中所处位置的索引编号，如果没有则返回-1&lt;/p&gt;

&lt;p&gt;remove：移除一个对象，如果成功返回true，否则（比如不存在）返回false（removeAll，顺序无关）&lt;/p&gt;

&lt;p&gt;subList：从列表中创建出一个片段&lt;/p&gt;

&lt;p&gt;retainAll：查找两个列表的交集&lt;/p&gt;

&lt;p&gt;set：在指定的索引处将原先的元素替换&lt;/p&gt;

&lt;p&gt;toArray：默认将列表转换成一个Object数组，如果参数提供特定类型的数组，则会返回一个这个类型的数组（如果能通过类型检查），如果提供的数组够大，会将元素放在这个数组中&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
List的addAll方法支持在中间插入一个序列&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;迭代器&lt;/h3&gt;
&lt;p&gt;JAVA的Iterator只能单向移动&lt;/p&gt;

&lt;p&gt;使用容器的iterator()方法获得该容器的一个迭代器，该迭代器将准备好返回序列的第一个元素&lt;/p&gt;

&lt;p&gt;next()：返回下一个元素，即第一次调用next方法时将返回第一个元素&lt;/p&gt;

&lt;p&gt;hasNext()：检查是否还有元素&lt;/p&gt;

&lt;p&gt;remove()：将迭代器next产生的最后一个元素删除，即使用remove前必须先调用next&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
迭代器的好处：将遍历序列的操作和序列底层的结构分离。迭代器统一了对容器的访问方式&lt;/p&gt;

&lt;h4 id=&quot;listiterator&quot;&gt;ListIterator&lt;/h4&gt;
&lt;p&gt;ListIterator可以双向移动&lt;/p&gt;

&lt;p&gt;previous()：返回当前元素并移动到上一个元素（和next相反）&lt;/p&gt;

&lt;p&gt;nextIndex()：返回下一次next方法将访问的下标&lt;/p&gt;

&lt;p&gt;previousIndex()：返回下一次previous方法将访问的下标&lt;/p&gt;

&lt;p&gt;previousIndex = nextIndex - 1&lt;/p&gt;

&lt;p&gt;set()：替换访问过的最后一个元素&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
可以给listIterator()方法传入一个int参数来返回一个指向指定下标元素的迭代器&lt;/p&gt;

&lt;h3 id=&quot;linkedlist&quot;&gt;LinkedList&lt;/h3&gt;
&lt;p&gt;LinkedList添加了可以使其用作栈，队列或双端队列的方法&lt;/p&gt;

&lt;p&gt;getFirst()：返回列表的头，如果列表为空则抛出NoSuchElementException&lt;/p&gt;

&lt;p&gt;element()：同上&lt;/p&gt;

&lt;p&gt;peek()：同上，但列表为空时返回null&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
remove()：移除并返回列表的头，如果列表为空则抛出NoSuchElementException&lt;/p&gt;

&lt;p&gt;removeLast()：同上&lt;/p&gt;

&lt;p&gt;poll()：同上，但列表为空时返回null&lt;/p&gt;

&lt;p&gt;element&lt;/p&gt;

&lt;p&gt;getFirst，get(int)，getLast&lt;/p&gt;

&lt;p&gt;offerFirst，offer，offerLast&lt;/p&gt;

&lt;p&gt;peekFirst，peek，peekLast&lt;/p&gt;

&lt;p&gt;pollFirst，poll，pollLast&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
pop，push&lt;/p&gt;

&lt;p&gt;remove() = removeFirst()，remove(int)， remove(Object)&lt;/p&gt;

&lt;p&gt;removeFirst， removeLast&lt;/p&gt;

&lt;p&gt;removeFirstOccurrence，removeLastOccurrence&lt;/p&gt;

&lt;h3 id=&quot;stack&quot;&gt;Stack&lt;/h3&gt;
&lt;p&gt;Stack继承自Vector类，因此是线程安全的&lt;/p&gt;

&lt;h3 id=&quot;set&quot;&gt;Set&lt;/h3&gt;
&lt;p&gt;通常会选择一个HashSet的实现，因为查找是Set最重要的操作&lt;/p&gt;

&lt;p&gt;Set具有和Collection完全一样的接口，因此没有任何额外的功能（实际上Set就是Collection）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
HashSet使用了散列，TreeSet将元素存储在红黑树数据结构中&lt;/p&gt;

&lt;p&gt;如果希望得到排序的结果，可以使用TreeSet&lt;/p&gt;

&lt;p&gt;可以向TreeSet的构造器传入一个比较器Comparator（String.CASE_INSENSITIVE_ORDER）&lt;/p&gt;

&lt;p&gt;contains()：测试对象是否在集合中&lt;/p&gt;

&lt;h3 id=&quot;map&quot;&gt;Map&lt;/h3&gt;
&lt;p&gt;容器不能用于基本类型&lt;/p&gt;

&lt;p&gt;containsKey：键是否存在&lt;/p&gt;

&lt;p&gt;containsValue：值是否存在&lt;/p&gt;

&lt;p&gt;keySet：返回包含所有键的集合（在foreach语句被使用）&lt;/p&gt;

&lt;p&gt;values：返回包含所有值得Collection（值可以重复）&lt;/p&gt;

&lt;p&gt;entrySet：返回所有键值对的集合&lt;/p&gt;

&lt;h3 id=&quot;queue&quot;&gt;Queue&lt;/h3&gt;
&lt;p&gt;先进先出（FIFO）的容器&lt;/p&gt;

&lt;p&gt;LinkedList之所有支持队列的行为，是因为它实现了Queue接口&lt;/p&gt;

&lt;p&gt;相关方法：offer，peek，poll，add，remove&lt;/p&gt;

&lt;h4 id=&quot;priorityqueue&quot;&gt;PriorityQueue&lt;/h4&gt;

&lt;p&gt;当使用offer方法往PriorityQueue插入元素时，会在队列中被排序（维护一个堆），默认排序方式是自然排序。当调用peek，poll，remove方法，都会确保获得优先级最大的元素（最小的值拥有最大优先级）&lt;/p&gt;

&lt;p&gt;可以自定义Comparator（Collections.reverseOrder()）&lt;/p&gt;

&lt;h3 id=&quot;collectioniterator&quot;&gt;Collection和Iterator&lt;/h3&gt;

&lt;p&gt;AbstractCollection提供了Collection的默认实现，如果要自定义Collection，可以创建AbstractCollection的子类型&lt;/p&gt;

&lt;p&gt;必须要自己实现iterator()和size()方法&lt;/p&gt;

&lt;h3 id=&quot;foreach&quot;&gt;foreach和迭代器&lt;/h3&gt;

&lt;p&gt;foreach语法可以适用于任何Collection对象&lt;/p&gt;

&lt;p&gt;Iterable接口包含了一个能产生迭代器的iterator()方法，任何实现Iterable的类都能用于foreach语句&lt;/p&gt;

&lt;p&gt;Collection类是Iterable，但Map不是&lt;/p&gt;

&lt;p&gt;数组不是Iterable，但可以用于foreach，而且数组没有自动包装机制，数组不能转成Iterable&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;适配器方法惯用法&lt;/h4&gt;

&lt;p&gt;如果直接将对象置于foreach语句中，将得到默认的迭代器（调用了iterable()）&lt;/p&gt;

&lt;p&gt;如果在Iterable类中添加方法，返回一个产生反向迭代器的Iterable对象（该类操作的是原Iterable对象的数据），相当于调用一个方法，将自己变成另一种Iterable在返回，而这种Iterable能够返回反向的迭代器&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
Arrays.asList方法产生的队列，如果对其进行修改，也会影响到原数组&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-6&quot;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;suzuki一旦生成，就不能改变容量&lt;/li&gt;
  &lt;li&gt;Collection保存单一元素，Map保存相关联的键值对。容器会自动调整尺寸。容器不能持有基本类型。容器有自动包装机制&lt;/li&gt;
  &lt;li&gt;如果需要大量的随机访问，应该使用ArrayList，如果需要经常从表中插入或删除元素，应该使用LinkedList&lt;/li&gt;
  &lt;li&gt;各种Queue以及栈的行为，由LinkedList提供支持&lt;/li&gt;
  &lt;li&gt;新程序不应使用过时的Vector，Hashtable和Stack&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Wed, 07 Sep 2016 13:39:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/07/Java-holding-objects/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/07/Java-holding-objects/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：内部类</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;创建内部类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;链接到外部类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#this-new&quot; id=&quot;markdown-toc-this-new&quot;&gt;.this和 .new&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;内部类和向上转型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;方法和作用域内的内部类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;匿名内部类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;嵌套类&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;接口内部&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;为什么需要内部类&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;闭包和回调&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;内部类的继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;内部类的覆盖&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;内部类标识符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内部类：将一个类的定义放在另一个类的定义内部&lt;/p&gt;

&lt;p&gt;把一些逻辑相关的类组织在一起，并控制内部类的可视性&lt;/p&gt;

&lt;p&gt;内部类与组合是完全不同的概念&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;创建内部类&lt;/h2&gt;

&lt;p&gt;从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体指明对象的类型：OuterClassName.InnerClassName&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;链接到外部类&lt;/h2&gt;

&lt;p&gt;内部类对象能访问其外围对象的所有成员，不需要任何条件&lt;/p&gt;

&lt;p&gt;当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用，用这个引用来访问外围类的成员&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;this-new&quot;&gt;.this和 .new&lt;/h2&gt;

&lt;p&gt;如果内部类需要得到对应外部类对象的引用，使用外部类名 + .this&lt;/p&gt;

&lt;p&gt;手动创建内部类对象时，由于需要外部类对象为前提，所以在new表达式中要提供外部类对象的引用&lt;/p&gt;

&lt;p&gt;必须使用外部类对象来创建内部类对象&lt;/p&gt;

&lt;p&gt;在拥有外部类对象之前是不可能创建内部类对象的&lt;/p&gt;

&lt;p&gt;如果内部类是嵌套类（静态内部类），则不需要外部类对象的前提&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;内部类和向上转型&lt;/h2&gt;

&lt;p&gt;当内部类是实现了某个接口，然后将一个对象向上转型为接口类型，就可以很好地隐藏内部类的细节&lt;/p&gt;

&lt;p&gt;private内部类甚至不能访问其名字，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;方法和作用域内的内部类&lt;/h2&gt;

&lt;p&gt;可以在一个方法里面或者在任意的作用域内定义内部类&lt;/p&gt;

&lt;p&gt;理由：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;快速实现某个接口并返回其引用&lt;/li&gt;
  &lt;li&gt;需要一个辅助的类，但又不希望它是公共可用的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在方法作用域内定义的类称作局部内部类&lt;/p&gt;

&lt;p&gt;局部内部类的定义不会造成命名冲突&lt;/p&gt;

&lt;p&gt;局部内部类在编译时已经被编译了，因此其定义与作用域无关，而是在该作用域外不可用&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-4&quot;&gt;匿名内部类&lt;/h2&gt;

&lt;p&gt;使用匿名内部类可以快速返回一个基类或接口的实现&lt;/p&gt;

&lt;p&gt;return new 基类/接口名(参数列表) {实现}&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
如果定义一个匿名内部类，需要使用一个在定义外部的对象，那么这个对象的引用必须是final的&lt;/p&gt;

&lt;p&gt;匿名内部类没有名字，因此没有构造器，如果需要进行一些初始化，可以使用实例初始化&lt;/p&gt;

&lt;p&gt;匿名内部类可以继承类，也可以实现接口，但是只能选一个，而且只能实现一个接口&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-5&quot;&gt;嵌套类&lt;/h2&gt;

&lt;p&gt;静态的内部类即嵌套类&lt;/p&gt;

&lt;p&gt;创建嵌套类的对象，不需要外围类的对象&lt;/p&gt;

&lt;p&gt;不能用嵌套类的对象访问非静态的外围类对象&lt;/p&gt;

&lt;p&gt;普通内部类不能有静态数据和静态字段，而嵌套类可以有&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;接口内部&lt;/h3&gt;
&lt;p&gt;接口内部可以放置嵌套类（由于放置在接口中的类都自动是public和static的）&lt;/p&gt;

&lt;p&gt;可以在内部类中实现其外围接口&lt;/p&gt;

&lt;p&gt;在一个接口中预置多种实现，可以使用嵌套类进行实现&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
内部类可以访问所有它嵌入的外围类的所有成员&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;为什么需要内部类&lt;/h2&gt;

&lt;p&gt;由于内部类可以访问外围类的成员，所以内部类提供某种访问外围类的窗口&lt;/p&gt;

&lt;p&gt;每个内部类都可以独立得继承一个接口的实现，对外围类来说相当于某种意义上的多重继承&lt;/p&gt;

&lt;p&gt;内部类的其他特性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;内部类可以有多个实例，内部类的状态都是相互独立的&lt;/li&gt;
  &lt;li&gt;在一个外围类内可以让多个内部类以不同形式实现一个接口&lt;/li&gt;
  &lt;li&gt;内部类是一个独立的实体&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-8&quot;&gt;闭包和回调&lt;/h3&gt;

&lt;p&gt;闭包是一个可调用的对象，它记录了一些信息，这些信息来自创建它的作用域&lt;/p&gt;

&lt;p&gt;内部类是面向对象的闭包&lt;/p&gt;

&lt;p&gt;JAVA通过闭包提供了回调机制，可以在运行时动态地决定调用什么方法&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-9&quot;&gt;内部类的继承&lt;/h2&gt;
&lt;p&gt;由于内部类的实例化需要外围类的对象，所以内部类的导出类，其构造器必须要有那个外围类对象的引用，然后再构造器中调用super()，才能编译通过&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-10&quot;&gt;内部类的覆盖&lt;/h2&gt;
&lt;p&gt;基类和导出类中的两个同名内部类是相互独立的，各自在自己的命名空间中&lt;/p&gt;

&lt;p&gt;局部内部类不能有访问说明符，因为它不是外围类的成员&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-11&quot;&gt;内部类标识符&lt;/h2&gt;
&lt;p&gt;内部类的类文件名为：外围类名字 + $ + 内部类名字&lt;/p&gt;

&lt;p&gt;如果内部类是匿名的，会产生一个数字作为标识符&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
如果一个内部类是嵌套在别的内部类中，直接将其名字放在外围类标识符和$后面&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Sep 2016 13:30:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/07/Java-inner-class/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/07/Java-inner-class/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：接口</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;抽象类和抽象方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;接口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;完全解耦&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;多重继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;通过继承扩展接口&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;名字冲突&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;适配接口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;接口中的域&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;嵌套接口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;接口和工厂&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;抽象类和抽象方法&lt;/h2&gt;

&lt;p&gt;抽象类是介于普通类和接口之间的形式&lt;/p&gt;

&lt;p&gt;包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法， 该类必须限定为抽象的&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
为抽象类创建对象是不安全的，会产生错误&lt;/p&gt;

&lt;p&gt;导出类必须实现基类的抽象方法，否则该导出类也是抽象类&lt;/p&gt;

&lt;p&gt;必须用abstract关键字来限定抽象类和抽象方法&lt;/p&gt;

&lt;p&gt;抽象类可以没有任何抽象方法&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;接口&lt;/h2&gt;

&lt;p&gt;interface关键字产生一个完全抽象的“类”，其中根本没有任何具体实现，声明方法但没有任何方法体&lt;/p&gt;

&lt;p&gt;接口被用来建立类与类之间的协议&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;	
接口前可以添加public关键字，否则就具有包访问权限&lt;/p&gt;

&lt;p&gt;接口可以包含域，隐式地位static和final的&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;	
实现接口要使用implements关键字链接&lt;/p&gt;

&lt;p&gt;接口中的方法隐式地为public的。实现接口时，要实现的方法必须定义为public的，否则是包访问权限&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;	
可以将实现类对象向上转型为接口类型&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;完全解耦&lt;/h2&gt;

&lt;p&gt;遵循接口来遍写类，可以减轻接口和类型的耦合&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;多重继承&lt;/h2&gt;
&lt;p&gt;接口比抽象类更纯粹的地方在于，接口没有任何具体实现，即没有任何与接口相关的存储&lt;/p&gt;

&lt;p&gt;因此可以继承任意多个接口，并可以向上转型为任意一个接口&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
继承的类必须放在前面，后面跟着接口&lt;/p&gt;

&lt;p&gt;基类中的同名方法可以帮助实现接口中的方法&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
如果知道某事物应该成为一个基类，首先考虑让其成为接口&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-4&quot;&gt;通过继承扩展接口&lt;/h2&gt;
&lt;p&gt;接口可以继承接口，用extends&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;名字冲突&lt;/h3&gt;
&lt;p&gt;如果方法相同则不会有什么问题，但是如果签名或者返回类型不同，会导致接口间不相容（incompatible）&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;适配接口&lt;/h2&gt;
&lt;p&gt;一个接口可以有不同的实现方式&lt;/p&gt;

&lt;p&gt;常用的方法是策略模式：“你可以用任何你想要的对象来调用我的方法，只要你的对象遵循我的接口”&lt;/p&gt;

&lt;p&gt;接口对比类的强大之处：让方法接受接口，可以让任何一种类都适用该方法&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;接口中的域&lt;/h2&gt;
&lt;p&gt;接口中的任何域都自动是static，final和public的&lt;/p&gt;

&lt;p&gt;接口中的域不能是空final，但可以被非常量表达式初始化&lt;/p&gt;

&lt;p&gt;这些域不是接口的一部分，被存储在接口的静态存储区域内&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-8&quot;&gt;嵌套接口&lt;/h2&gt;
&lt;p&gt;接口可以嵌套在其他接口中&lt;/p&gt;

&lt;p&gt;实现某个接口时，不需要实现嵌套在内部的接口&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-9&quot;&gt;接口和工厂&lt;/h2&gt;
&lt;p&gt;典型设计模式：工厂方法模式&lt;/p&gt;

&lt;p&gt;代码将完全和接口的实现分离，可以透明地将某个实现替换为另一个实现&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Sep 2016 13:26:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/07/Java-interface/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/07/Java-interface/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：多态</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;向上转型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;方法调用绑定&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;缺陷&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;覆盖私有方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;域与静态方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;构造器&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;销毁&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;继承&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;纯继承与扩展&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;向下转型&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多态是数据抽象和继承之后的第三种基本特征&lt;/p&gt;

&lt;p&gt;利用多态可以创建可扩展的程序&lt;/p&gt;

&lt;p&gt;多态可以消除类型之间的耦合关系&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;向上转型&lt;/h2&gt;
&lt;p&gt;向上转型会将接口缩小至基类的大小&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;方法调用绑定&lt;/h2&gt;

&lt;p&gt;绑定：将一个方法调同一个方法主体关联起来&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;前期绑定：程序执行前进行绑定（编译器和连接程序），默认的绑定方式&lt;/li&gt;
  &lt;li&gt;后期绑定：程序运行时根据对象的类型进行绑定，又叫动态绑定和运行时绑定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JAVA中除了static方法和final方法之外，所有方法都是后期绑定&lt;/p&gt;

&lt;p&gt;帮助设计可扩展的程序&lt;/p&gt;

&lt;p&gt;多态是一项将改变的事物和未变的事物分离开来的重要技术&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缺陷&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;覆盖私有方法&lt;/h3&gt;
&lt;p&gt;覆盖private方法将会产生一个全新的方法&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;域与静态方法&lt;/h3&gt;
&lt;p&gt;只有普通的方法调用可以是多态的&lt;/p&gt;

&lt;p&gt;域的访问是编译时解析的，导出类默认访问自己的域，要访问基类的域要使用关键字super&lt;/p&gt;

&lt;p&gt;静态方法是与类而不是对象相关联的&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;构造器&lt;/h2&gt;
&lt;p&gt;构造器实际上是static方法，因此不具有多态性&lt;/p&gt;

&lt;p&gt;基类的构造器总是在导出类的构造过程中被调用，并且沿着继承层次向上链接&lt;/p&gt;

&lt;p&gt;如果没有指定调用哪个构造器，默认调用基类的默认构造器&lt;/p&gt;

&lt;p&gt;构造器调用顺序：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用基类构造器&lt;/li&gt;
  &lt;li&gt;按声明顺序初始化成员&lt;/li&gt;
  &lt;li&gt;调用导出类构造器主体&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-6&quot;&gt;销毁&lt;/h3&gt;
&lt;p&gt;销毁的顺序应该和初始化顺序相反，即声明的初始化顺序&lt;/p&gt;

&lt;p&gt;先对导出类进行清理，然后才是基类&lt;/p&gt;

&lt;p&gt;如果有成员对象是被共享的，必须使用引用计数&lt;/p&gt;

&lt;p&gt;遍写构造器时避免使用其他方法，唯一能安全调用的是基类中的final方法&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;继承&lt;/h2&gt;

&lt;p&gt;继承设计准则：继承表达行为间差异，用字段表达状态上的变化&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;纯继承与扩展&lt;/h3&gt;

&lt;p&gt;导出类具有基类的接口&lt;/p&gt;

&lt;p&gt;纯继承：导出类可以完全代替基类&lt;/p&gt;

&lt;p&gt;导出类中扩展接口部分不能被基类访问&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;向下转型&lt;/h3&gt;

&lt;p&gt;所有转型都会得到检查，运行时进行检查，如果不是会返回ClassCastException（运行时类型识别RTTI）&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Sep 2016 11:50:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/05/Java-polymorphism/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/05/Java-polymorphism/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：复用类</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;组合&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;继承&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;初始化基类&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;代理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;结合使用组合和继承&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;确保正确清理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;名称屏蔽&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;选择组合或继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#protected&quot; id=&quot;markdown-toc-protected&quot;&gt;protected&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;向上转型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#final&quot; id=&quot;markdown-toc-final&quot;&gt;final关键字&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#final-1&quot; id=&quot;markdown-toc-final-1&quot;&gt;final数据&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#final-2&quot; id=&quot;markdown-toc-final-2&quot;&gt;空白final&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#final-3&quot; id=&quot;markdown-toc-final-3&quot;&gt;final参数&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#final-4&quot; id=&quot;markdown-toc-final-4&quot;&gt;final方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#final-5&quot; id=&quot;markdown-toc-final-5&quot;&gt;final类&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;初始化以及类的加载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;复用代码最简单的方式就是复制代码
可以通过创建新类进行复用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在新类中产生现有类的对象（组合）&lt;/li&gt;
  &lt;li&gt;按照现有类来创建新类（继承）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;组合&lt;/h2&gt;

&lt;p&gt;每一个非基本类型的类都有一个toString方法
类中基本类型的域会自动初始化为0，对象引用初始化为null
null引用可以被打印&lt;/p&gt;

&lt;p&gt;初始化引用的方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义的地方。这将会在构造器之前执行&lt;/li&gt;
  &lt;li&gt;构造器中&lt;/li&gt;
  &lt;li&gt;正要使用之前。也叫惰性初始化&lt;/li&gt;
  &lt;li&gt;使用实例初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;继承&lt;/h2&gt;
&lt;p&gt;创建一个类时，总是在继承。除非显式指出继承某类，否则将隐式继承Object类
继承将自动获得基类的所有域和方法
使用super关键字调用基类版本的域或方法&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;初始化基类&lt;/h3&gt;
&lt;p&gt;创建一个导出类的对象时，该对象会包含一个基类的子对象
导出类的构造器中自动先调用基类的构造器
构造过程是从基类向外扩散的，即先调用基类的，再调用导出类的。这使得基类内容在导出类可以访问它时，就已经完成了初始化&lt;/p&gt;

&lt;p&gt;Java会调用的是基类的默认构造器，如果基类没有，需要用super显式地调用基类的带参构造器
调用基类构造器必须是导出类构造器中的第一件事&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;代理&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;代理是一个编程模式，是继承和组合的中庸之道&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将成员对象置于类中（组合），在类中暴露成员对象的所有方法（类似继承），相当于新类代理了各个成员对象的行为&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;结合使用组合和继承&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;确保正确清理&lt;/h3&gt;
&lt;p&gt;由于不知道垃圾回收器何时回收，因此需要显式地遍写方法来进行收尾
可以使用try-finally代码块。无论try是如何退出的，finally块总会被执行&lt;/p&gt;

&lt;p&gt;清理顺序应和构造顺序相反&lt;/p&gt;

&lt;p&gt;不要使用finalize&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;名称屏蔽&lt;/h3&gt;
&lt;p&gt;在导出类中对基类的方法进行重载，不会屏蔽基类的所有重载版本
&lt;code class=&quot;highlighter-rouge&quot;&gt;@Override&lt;/code&gt;注解可以防止在不想重载时意外进行了重载&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;选择组合或继承&lt;/h2&gt;
&lt;p&gt;组合和继承都是在新类中放置子对象，组合是显式的，继承是隐式的
组合通常是希望在新类中使用现有类的功能，而并非得到其接口。用户看到的只有新类的接口，而看不到成员的接口
继承是希望使用现有类，开发它的特殊版本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;组合 = has-a&lt;/li&gt;
  &lt;li&gt;继承 = is-a&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;protected&quot;&gt;protected&lt;/h2&gt;
&lt;p&gt;继承使protected关键字具有意义
应尽量使用private，然后用protected限制继承者的访问权限&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;向上转型&lt;/h2&gt;
&lt;p&gt;称为向上转型是因为，类层次关系中基类是上层的
向上转型总是安全的
向上转型会丢失信息
向上转型的过程中，类接口只会丢失方法，而不会获取方法&lt;/p&gt;

&lt;p&gt;继承应当慎用，使用继承前应考虑是否需要进行向上转型&lt;/p&gt;

&lt;h2 id=&quot;final&quot;&gt;final关键字&lt;/h2&gt;

&lt;h3 id=&quot;final-1&quot;&gt;final数据&lt;/h3&gt;
&lt;p&gt;final的作用是向编译器通知一块数据是恒定不变的&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;永不改变的编译时常量&lt;/li&gt;
  &lt;li&gt;运行时初始化的值，希望不被改变&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JAVA会对final使用优化进行优化，对于域会在编译时计算表达式，对于方法会使用内嵌机制
编译时常量必须是基本类型，定义该常量时必须对其进行赋值&lt;/p&gt;

&lt;p&gt;final修饰对象引用时，表示该引用恒定不变。一旦该引用指向一个对象，就不能指向别的对象&lt;/p&gt;

&lt;p&gt;JAVA编写规范中，既是static又是final的域命名用大写，用下划线分隔单词&lt;/p&gt;

&lt;h3 id=&quot;final-2&quot;&gt;空白final&lt;/h3&gt;
&lt;p&gt;声明为final但没有给定初值的域
无论如何，必须在域的定义处或每个构造器中对final进行赋值，否则将会在使用该域时产生异常&lt;/p&gt;

&lt;h3 id=&quot;final-3&quot;&gt;final参数&lt;/h3&gt;
&lt;p&gt;表示无法在方法中更改参数的值或指向的对象&lt;/p&gt;

&lt;h3 id=&quot;final-4&quot;&gt;final方法&lt;/h3&gt;
&lt;p&gt;使用final方法的原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;锁定方法，防止导出类修改其含义&lt;/li&gt;
  &lt;li&gt;效率。使用内嵌调用提高效率&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;类中的private方法都隐式地指定为final
覆盖一个private方法不会导致错误，但不会覆盖，而是产生了一个新方法&lt;/p&gt;

&lt;h3 id=&quot;final-5&quot;&gt;final类&lt;/h3&gt;
&lt;p&gt;表示无法被继承
类中的所有方法都隐式指定为final&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;初始化以及类的加载&lt;/h2&gt;
&lt;p&gt;编译代码文件只有在需要使用时才会被加载
加载发生于创建类的第一个对象或者访问静态域或方法时
所有的静态域和代码段都会在加载时，按照书写顺序依次初始化&lt;/p&gt;

&lt;p&gt;在使用导出类时，会加载基类
对于静态成员，会先初始化基类的&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Sep 2016 11:46:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/05/Java-reuse-class/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/05/Java-reuse-class/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：访问权限控制</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;包&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;代码组织&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;包名&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#import-static&quot; id=&quot;markdown-toc-import-static&quot;&gt;import static&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#import&quot; id=&quot;markdown-toc-import&quot;&gt;用import改变行为&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;JAVA访问权限修饰词&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;包访问权限&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#public&quot; id=&quot;markdown-toc-public&quot;&gt;public&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#private&quot; id=&quot;markdown-toc-private&quot;&gt;private&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#protected&quot; id=&quot;markdown-toc-protected&quot;&gt;protected&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#protected-1&quot; id=&quot;markdown-toc-protected-1&quot;&gt;protected也提供包访问权限&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;接口和实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;类访问权限&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;访问权限控制的等级，从大到小依次为：
public，protected，包访问权限，private&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;包&lt;/h2&gt;
&lt;p&gt;包是库单元&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;代码组织&lt;/h3&gt;
&lt;p&gt;一个JAVA源代码文件是一个编译单元（转译单元）
编译单元内有一个或零个public类，该类名必须和编译单元名字相同
编译单元内其他的类不能为public&lt;/p&gt;

&lt;p&gt;JAVA可执行程序是class文件
如果使用package语句，必须是文件非注释的第一句代码&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;包名&lt;/h3&gt;
&lt;p&gt;包名的第一部分是类创建者的反序域名
整个包名为小写
包路径中除包名给出的相对路径外的部分，在环境变量CLASSPATH给出
使用JAR则必须在CLASSPATH中给出完整路径&lt;/p&gt;
&lt;h3 id=&quot;import-static&quot;&gt;import static&lt;/h3&gt;
&lt;p&gt;使用import static可以导入对应类中的静态方法，可用于定制工具库&lt;/p&gt;
&lt;h3 id=&quot;import&quot;&gt;用import改变行为&lt;/h3&gt;
&lt;p&gt;相当于条件编译，不同包下有相似的类，那么可以通过修改import的包来改变程序的行为&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;JAVA访问权限修饰词&lt;/h2&gt;
&lt;p&gt;无论如何，所有事物都具有某种形式的访问权限控制&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;包访问权限&lt;/h2&gt;
&lt;p&gt;对于包外的类相当于 private
包访问权限为包的存在具有意义&lt;/p&gt;

&lt;p&gt;取得某成员的访问权限的途径
	1. 使其成为public
	2. 不加访问权限修饰词，并与其类置于同一包内
	3. 继承类，可以获得public和protected成员的访问权限，private不行，包访问权限的只能包内继承才行
	4. 提供get/set方法&lt;/p&gt;
&lt;h2 id=&quot;public&quot;&gt;public&lt;/h2&gt;
&lt;p&gt;没有指定package的类，全部归属于对应目录下的默认包中&lt;/p&gt;
&lt;h2 id=&quot;private&quot;&gt;private&lt;/h2&gt;
&lt;p&gt;一个使用方法是让构造器私有化，控制对象的创建&lt;/p&gt;
&lt;h2 id=&quot;protected&quot;&gt;protected&lt;/h2&gt;
&lt;p&gt;处理的是继承的概念&lt;/p&gt;
&lt;h2 id=&quot;protected-1&quot;&gt;protected也提供包访问权限&lt;/h2&gt;

&lt;h1 id=&quot;section-4&quot;&gt;接口和实现&lt;/h1&gt;
&lt;p&gt;访问权限控制相当于具体实现的隐藏
数据和方法放进类中 + 具体实现的隐藏 = 封装&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;类访问权限&lt;/h1&gt;
&lt;p&gt;public：希望某个类可以被客户使用
注意：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;每个编译单元只能有一个public类&lt;/li&gt;
  &lt;li&gt;public类的名称必须和编译单元文件名相同，大小写区分&lt;/li&gt;
  &lt;li&gt;编译单元可以没有public类，此时命名随意&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不是public的类具有包访问权限
类没有private和protected情况
如果某个包访问权限的类含有public的静态成员，客户可以使用这个静态成员，但不可以生成该类的对象&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Sep 2016 11:19:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/04/Java-access-control/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/04/Java-access-control/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：初始化和清理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;构造器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;方法重载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;默认构造器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#this&quot; id=&quot;markdown-toc-this&quot;&gt;this关键字&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#static&quot; id=&quot;markdown-toc-static&quot;&gt;static&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;清理&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#finalize&quot; id=&quot;markdown-toc-finalize&quot;&gt;finalize的用途&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#finalize-1&quot; id=&quot;markdown-toc-finalize-1&quot;&gt;使用finalize的情形&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;垃圾回收器&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;引用计数&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;停止-复制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;标记-清扫&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#generation&quot; id=&quot;markdown-toc-generation&quot;&gt;generation&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;成员初始化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;构造器初始化&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;初始化顺序&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;静态数据初始化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;显示的静态初始化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;非静态实例初始化&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-14&quot; id=&quot;markdown-toc-section-14&quot;&gt;数组初始化&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot; id=&quot;markdown-toc-section-15&quot;&gt;可变参数列表&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-16&quot; id=&quot;markdown-toc-section-16&quot;&gt;枚举类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;构造器&lt;/h2&gt;
&lt;p&gt;构造器没有返回值&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;方法重载&lt;/h2&gt;
&lt;p&gt;每个重载方法都有一个独一无二的参数类型列表
如果传入的数据类型小于声明的形参类型，数据类型会被提升，char会提升为int
如果传入的数据类型大于声明的形参类型，需要显式类型转换
不能通过返回类型来区分重载方法&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;默认构造器&lt;/h2&gt;
&lt;p&gt;如果类中无构造器，编译器会自动创建一个默认构造器
如果已经声明了一个构造器，编译器不会创建默认构造器&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;this&quot;&gt;this关键字&lt;/h2&gt;
&lt;p&gt;this相当于该对象的一个引用
this只能在方法内部使用&lt;/p&gt;

&lt;p&gt;构造器中可以调用另一个构造器，用this加参数列表表示，但只能调用一个，且该调用语句必须置于最起始处&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;static&quot;&gt;static&lt;/h2&gt;
&lt;p&gt;静态方法内不能调用非静态方法，反之则可以
可以用类本身调用
JAVA禁止全局方法（万物皆对象）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;清理&lt;/h2&gt;
&lt;p&gt;注意的三点&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;对象不一定会被垃圾回收&lt;/li&gt;
  &lt;li&gt;垃圾回收不等于析构&lt;/li&gt;
  &lt;li&gt;垃圾回收只与内存有关&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦垃圾回收器准备释放一个对象，会先调用其finalize方法，再洗一次垃圾回收发生时才真正回收&lt;/p&gt;
&lt;h3 id=&quot;finalize&quot;&gt;finalize的用途&lt;/h3&gt;
&lt;p&gt;finalize只针对通过创建对象的方式以外的方式为对象分配的存储空间，即C和C++的情况
这种情况通常发生在使用“本地方法”（native method）的情况&lt;/p&gt;

&lt;p&gt;如果JAVA虚拟机（JVM）没有发生内存耗尽的情况，就不会执行垃圾回收&lt;/p&gt;
&lt;h3 id=&quot;finalize-1&quot;&gt;使用finalize的情形&lt;/h3&gt;
&lt;p&gt;在对象被回收前发现存在的隐晦缺陷，比如打开的文件&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;垃圾回收器&lt;/h3&gt;
&lt;p&gt;垃圾回收器能提高对象的创建速度
垃圾回收器除了回收空间，还将存活的对象内存紧密排列&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;引用计数&lt;/h4&gt;
&lt;p&gt;简单，但速度慢
当对象间存在循环引用时，可能会出现引用计数不为零的情况
引用计数未被应用在任何JAVA虚拟机中&lt;/p&gt;

&lt;p&gt;解决方法：从堆栈和静态存储区中的引用开始遍历，找到所有被指向的对象，以及对象包含的引用，反复进行直到全部被访问为止&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;停止-复制&lt;/h4&gt;
&lt;p&gt;先暂停程序，将存活的对象复制到另一个堆中，并且紧凑排放&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;需要多一倍空间&lt;/li&gt;
  &lt;li&gt;在程序稳定时，只会产生少量垃圾，那么全部复制就很浪费&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-7&quot;&gt;标记-清扫&lt;/h4&gt;
&lt;p&gt;通过引用遍历所有对象，给对象设置一个标记，标记完后开始清扫，只回收没有标记的对象
剩下的堆空间将是不连续的&lt;/p&gt;

&lt;h4 id=&quot;generation&quot;&gt;generation&lt;/h4&gt;
&lt;p&gt;内存分配以内存块为单位，“停止-复制”的堆复制变成块复制
每个块用代数记录是否还存活，被引用则代数增加
垃圾回收器对上次新分配的块进行整理，因为大型对象占据整个块不会被复制，因此对处理大量临时对象很有帮助&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-8&quot;&gt;成员初始化&lt;/h2&gt;
&lt;p&gt;JAVA保证所有变量在使用前都会被适当地初始化。对于没有初始化的局部变量，会产生编译错误&lt;/p&gt;

&lt;p&gt;可以定义类成员变量时赋值
成员初始化顺序取决于定义顺序&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-9&quot;&gt;构造器初始化&lt;/h2&gt;
&lt;p&gt;自动初始化无论如何都会发生，然后才调用构造器&lt;/p&gt;
&lt;h3 id=&quot;section-10&quot;&gt;初始化顺序&lt;/h3&gt;
&lt;p&gt;变量定义的顺序决定了初始化的顺序&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;静态数据初始化&lt;/h3&gt;
&lt;p&gt;静态数据只占用一份内存，与对象个数无关
静态初始化只有在必要时才会进行。静态数据不会再被初始化
静态初始化在非静态初始化之前&lt;/p&gt;

&lt;p&gt;对于一个Dog类，其产生对象的过程：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;构造器实际上是静态方法。由于构造器第一次被访问，JAVA解释器定位Dog.class&lt;/li&gt;
  &lt;li&gt;载入Dog.class，这将会创建一个Class对象。静态初始化动作全部执行&lt;/li&gt;
  &lt;li&gt;为对象分配内存空间&lt;/li&gt;
  &lt;li&gt;该内存空间全部置零（默认初始化）&lt;/li&gt;
  &lt;li&gt;执行字段定义处的初始化&lt;/li&gt;
  &lt;li&gt;执行构造器&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-12&quot;&gt;显示的静态初始化&lt;/h3&gt;
&lt;p&gt;多个静态初始化动作可以用一个static块包括&lt;/p&gt;
&lt;h3 id=&quot;section-13&quot;&gt;非静态实例初始化&lt;/h3&gt;
&lt;p&gt;该子句在构造器之前执行
可以用于保证无论哪个构造器被调用，某些操作都会发生&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-14&quot;&gt;数组初始化&lt;/h2&gt;
&lt;p&gt;方括号可以放在标识符的前面或后面
所有数组都有一个成员length，会在越界访问时抛出异常&lt;/p&gt;

&lt;p&gt;数组的创建是运行时的
初始化列表最后的逗号是可选的&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;可变参数列表&lt;/h3&gt;
&lt;p&gt;如果没有定义toString方法，在打印对象时会输出类名+”@”+地址
可变参数获得的依然是一个数组
传递0个参数是可行的
可以和自动包装机制搭配使用&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-16&quot;&gt;枚举类型&lt;/h2&gt;
&lt;p&gt;创建enum时，会自动创建toString方法和ordinal方法
enum是类，具有自己的方法&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Sep 2016 10:58:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/02/Java-initialization-and-clean/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/02/Java-initialization-and-clean/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：控制执行流程</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#truefalse&quot; id=&quot;markdown-toc-truefalse&quot;&gt;true和false&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#if-else&quot; id=&quot;markdown-toc-if-else&quot;&gt;if-else&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;迭代&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#foreach&quot; id=&quot;markdown-toc-foreach&quot;&gt;foreach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#goto&quot; id=&quot;markdown-toc-goto&quot;&gt;goto&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#switch&quot; id=&quot;markdown-toc-switch&quot;&gt;switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;truefalse&quot;&gt;true和false&lt;/h2&gt;
&lt;p&gt;所有条件语句都用true和false决定执行路径
JAVA不允许将一个数字作为布尔值使用&lt;/p&gt;

&lt;h2 id=&quot;if-else&quot;&gt;if-else&lt;/h2&gt;
&lt;p&gt;else if不是关键字&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;迭代&lt;/h2&gt;
&lt;p&gt;JAVA中唯一使用到逗号操作符的地方，是for循环的控制表达式
无论是初始化还是步进部分，语句都是顺序执行的，而不是同时进行&lt;/p&gt;

&lt;h2 id=&quot;foreach&quot;&gt;foreach&lt;/h2&gt;
&lt;p&gt;体现了封装的特性
更加简洁的for语法&lt;/p&gt;

&lt;h2 id=&quot;goto&quot;&gt;goto&lt;/h2&gt;
&lt;p&gt;JAVA使用标签进行跳转
break和continue可配合标签使用，效果是先跳到标签对应的循环部分，然后再进行break/continue操作
JAVA使用标签的唯一理由是希望在多层嵌套中break或continue&lt;/p&gt;

&lt;h2 id=&quot;switch&quot;&gt;switch&lt;/h2&gt;
&lt;p&gt;只能对int，String或enum类型进行操作&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Sep 2016 10:48:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/09/02/Java-control-execution/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/09/02/Java-control-execution/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Java笔记整理：操作符</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;JAVA操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;优先级&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;赋值&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;算术操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;递增递减操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;关系操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;逻辑操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;直接常量&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;前缀&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;后缀&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;指数计数法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;位操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;移位操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;字符串操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;类型转换&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;java&quot;&gt;JAVA操作符&lt;/h2&gt;
&lt;p&gt;除“=”，“==”和“!=”外，所有操作符只能操作基本数据类型
String类支持“+”和“+=”&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;优先级&lt;/h2&gt;
&lt;p&gt;在连加的表达式中，String类型的元素后面的所有元素，都会自动转换成String类型&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;赋值&lt;/h2&gt;
&lt;p&gt;常量不能作为左值
基本数据变量存储的是实际的数值，赋值时会复制实际的内容
对象赋值时实际上是复制引用，而不是对象本身&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;算术操作符&lt;/h2&gt;
&lt;p&gt;整数除法会直接去掉小数位，而不是四舍五入
一元加操作符，像“+4”，会将较小类型的操作数提升为int&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;递增递减操作符&lt;/h2&gt;
&lt;p&gt;递增递减操作符是唯一具有“副作用”的操作符，即改变操作数&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;关系操作符&lt;/h2&gt;
&lt;p&gt;关系操作符会生成一个boolean结果
boolean类型不支持除“==”和“!=”外的比较符&lt;/p&gt;

&lt;p&gt;对象间进行比较时，实际上比较的是两个引用
JAVA内置的一些类的equals方法其实是重载了Object类的equals方法，equals方法默认比较引用&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;逻辑操作符&lt;/h2&gt;
&lt;p&gt;逻辑操作符会生成一个boolean结果
逻辑操作符的操作数只能是boolean类型，JAVA不允许将非布尔值当作布尔值使用
JAVA存在短路特性&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;直接常量&lt;/h2&gt;

&lt;h3 id=&quot;section-7&quot;&gt;前缀&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;十六进制：0x 或 0X&lt;/li&gt;
  &lt;li&gt;八进制：0&lt;/li&gt;
  &lt;li&gt;没有二进制（可以使用Integer.toBinaryString()方法获得）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-8&quot;&gt;后缀&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;long：l 或 L&lt;/li&gt;
  &lt;li&gt;double：d 或 D&lt;/li&gt;
  &lt;li&gt;float：f 或 F&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;试图将变量初始化成超出自身范围的值，会得到一条错误信息
如果没有后缀，会默认转换成int值&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;指数计数法&lt;/h2&gt;
&lt;p&gt;编译器会将指数作为double类型处理&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;位操作符&lt;/h2&gt;
&lt;p&gt;~是一元操作符，因此没有~=
boolean类型可以应用于位操作符，但不能使用 ~ 操作符
位操作符表达式不会中途短路&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;移位操作符&lt;/h2&gt;
&lt;p&gt;左移低位补零
右移高位正数补零，负数补一（»&amp;gt;则全部补零）&lt;/p&gt;

&lt;p&gt;char，byte和short在移位前会先转换成int，移位后截断转换为原来的类型
int和long移位后的位数不会超过自身的最大位数&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;字符串操作符&lt;/h2&gt;
&lt;p&gt;JAVA不能重载操作符
如果表达式以一个字符串开头，后续所有操作数都会被转换成字符串类型&lt;/p&gt;

&lt;p&gt;JAVA可以通过编译时检查防止while(x=y)这种错误的发生，因为int类型不能转换为boolean类型，除非像true=false，则不会得到错误。同样的，也可以防止逻辑操作符和位操作符的混淆&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;类型转换&lt;/h2&gt;
&lt;p&gt;窄化转换可能会导致信息丢失
扩展转换不必显示进行，会自动发生&lt;/p&gt;

&lt;p&gt;将float和double转换成int类型时，会进行截尾而不是舍入
对char，byte或short的数据进行算术运算或位运算时，运算之前会自动转换成int&lt;/p&gt;

&lt;p&gt;表达式中出现的最大数据类型决定了最终结果的数据类型&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;JAVA没有sizeof，因为在所有机器上的数据类型大小都是没有区别的&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Aug 2016 11:36:00 +0800</pubDate>
        <link>http://mahong978.github.io/2016/08/31/Java-operator/</link>
        <guid isPermaLink="true">http://mahong978.github.io/2016/08/31/Java-operator/</guid>
        
        <category>java</category>
        
        
        <category>java</category>
        
      </item>
    
  </channel>
</rss>
